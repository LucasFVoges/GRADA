#regex_string <- paste0(regex_string, "|")
}
# A little help for too time consuming approaches:
if (possibles %% 100 == 0 || possibles == pt_possibils) {
print(paste0("regex for ", missM, " mism.: ", possibles, " of ", pt_possibils, " combinations!"))
}
}
regex_string
adapter <- "AAAAAAAAAAATTTTTTTTT"
missM <- 3
regex_string <- ""
length_adapter <- nchar(adapter)
char_adapter <- strsplit(adapter, "")[[1]]
# This will look in the pascal triangle for max number of possible combinations:
# Old: pt_possibils <- lapply(length_adapter, function(i) choose(i, missM))[[1]]
pt_possibils <- choose(length_adapter, missM)
# the combinations are available via combn()
pt_combinations <- combn(1:length_adapter, missM, simplify = TRUE)    # error if missM higher than length of adapter!
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
## faster alternative?
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
# n <- 1  # num value for base
# for (base in strsplit(adapter, "")[[1]]) {
#   if (n %in% pt_combinations[,possibles]) {
#     if (n == length_adapter) {
#       regex_string <- paste0(regex_string, ".{0,1}")  # because insertion at the end is pointless.
#     } else {
#       regex_string <- paste0(regex_string, "(.{0,1}|", base, ".)") # This allown Indels as well. Without it would be just "."
#     }
#   } else {
#     regex_string <- paste0(regex_string, base)2
#   }
#   n <- n + 1
# }
# Warum lÃ¤uft das nicht????
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
#regex_string <- paste0(regex_string, "|")
}
# A little help for too time consuming approaches:
if (possibles %% 100 == 0 || possibles == pt_possibils) {
print(paste0("regex for ", missM, " mism.: ", possibles, " of ", pt_possibils, " combinations!"))
}
}
regex_string
adapter <- "AAAAAAAAAATTTTTTTTTTTCCCCCCCCCCTTTTTTTTTT"
missM <- 3
regex_string <- ""
length_adapter <- nchar(adapter)
char_adapter <- strsplit(adapter, "")[[1]]
# This will look in the pascal triangle for max number of possible combinations:
# Old: pt_possibils <- lapply(length_adapter, function(i) choose(i, missM))[[1]]
pt_possibils <- choose(length_adapter, missM)
# the combinations are available via combn()
pt_combinations <- combn(1:length_adapter, missM, simplify = TRUE)    # error if missM higher than length of adapter!
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
#regex_string <- paste0(regex_string, "|")
}
# A little help for too time consuming approaches:
if (possibles %% 100 == 0 || possibles == pt_possibils) {
print(paste0("regex for ", missM, " mism.: ", possibles, " of ", pt_possibils, " combinations!"))
}
}
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 2,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 2
)
grada_table_simple(input = "temp/example/")   # needs (kable, knitr)
```{r, eval=TRUE}3
library(GRADA)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar_full(PE = FALSE, skip = TRUE, input = "temp/example/", M_min = 3, M_max=0)
```
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar_full(PE = FALSE, skip = TRUE, input = "temp/example/", M_min = 3, M_max=0)
```
library(GRADA)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 2, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 3, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 3,M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 3, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 2, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 2, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 1, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
writeLines <- sessionInfo()
writeLines <- sessionInfo()
a <- writeLines(sessionInfo())
sink(file = "S1.txt")
sessionInfo()
sink()
"S
sink(file = "S1.txt")
func <- function(){
sink(file = "S1.txt")
sessionInfo()
sink()
}
func
func()
func()
func <- function(){
sink(file = "S1.txt", type = output)
sessionInfo()
sink()
}
func()
func <- function(){
sink(file = "S1.txt", type = "output")
sessionInfo()
sink()
}
func()
func <- function(){
sessionInfo() %>% capture.output("S1.txt")
}
func()
func <- function(){
sessionInfo() %>% capture.output("S1.txt")
}
func()
func <- function(){
sessionInfo() %>% capture.output(file = "S1.txt")
}
func()
library(dplyr)
func <- function(){
sessionInfo() %>% capture.output(file = "S1.txt")
}
func()
func <- function(){
capture.output(sessionInfo(), file = "S1.txt")
}
func()
func()
detach("package:dplyr", unload = TRUE)
func <- function(){
capture.output(sessionInfo(), file = "S1.txt")
}
func()
if(exists(data.dir)){print("yes")}
if(exists(data.dir)){print("yes")}
if(exists(data.dir)){print("yes")}
if(exists("data.dir")){print("yes")}
if(exists("data.dir")){print("yes")}
if(exists("data.dir")){print("yes")} else {print("No")}
if(exists("data.dir")){print("yes")} else {print("No")}
data.dir <- 2
if(exists("data.dir")){print("yes")} else {print("No")}
load("S1.txt")
read.table("S1.txt")
read.delim("S1.txt")
a <- read.delim("S1.txt")
View(a)
a
a[11]
a[[11]]
a(11)
a[,11]
a[11,]
a <- read.delim("S1.txt", sep = "$")
a
View(a)
a[11,]
a <- read.delim("S1.txt", sep = ":")
View(a)
a <- read.delim("S1.txt", sep = ":_")
a <- read.delim("S1.txt", sep = "_")
View(a)
a <- read.delim("S1.txt", sep = "_")
a <- read.delim("S1.txt", sep = "\n")
View(a)
a <- read.delim("S1.txt")
View(a)
a[11,]
readLines("S1.txt")
a <- readLines("S1.txt")
a[1]
a[12]
a[11]
load(*.txt)
choose(20,3)
choose(30,3)
regex_string <- ""
adapter <- "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
missM <- 3
length_adapter <- nchar(adapter)
char_adapter <- strsplit(adapter, "")[[1]]
# This will look in the pascal triangle for max number of possible combinations:
# Old: pt_possibils <- lapply(length_adapter, function(i) choose(i, missM))[[1]]
pt_possibils <- choose(length_adapter, missM)
# the combinations are available via combn()
pt_combinations <- combn(1:length_adapter, missM, simplify = TRUE)    # error if missM higher than length of adapter!
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (!simplify_regex){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
} else{
this_char_adapter[this_pos] <- "."
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
}
}
regex <- paste0("/",regex_string,"/")
regex_string
regex
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (!simplify_regex){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
} else{
this_char_adapter[this_pos] <- "."
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
}
}
simplyfy_regex <- FALSE
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (!simplify_regex){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
} else{
this_char_adapter[this_pos] <- "."
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
}
}
simplify_regex <- FALSE
for (this_pos in pt_combinations[,possibles]){
if (!simplify_regex){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
} else{
this_char_adapter[this_pos] <- "."
}
}
regex <- paste0("/",regex_string,"/")
regex
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (!simplify_regex){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
} else{
this_char_adapter[this_pos] <- "."
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
}
}
regex <- paste0("/",regex_string,"/")
regex
setwd("~/Dokumente/GITHUB/GRADA/example")
readlength <- 150
poslist <- c(0:(readlength-1))
adapter <- "AAAAAAAAAAAAAAAAAA"
missM <- 1
R <- 1
input <- "temp/example/"
length_adapter <- nchar(adapter)
agrep_position <- c()
lines_of_file <- as.integer(system(intern=TRUE, paste0("wc -l ", input, "temp_R", R, "_", adapter, "_M", missM,".txt | cut -f1 -d' '")))
if (lines_of_file > 0) {
# The approach with agrep per line:
for (readline in 1:lines_of_file) {
agrep_position <- c(agrep_position, as.integer(system(intern = TRUE, paste0("sed -n ", readline, "p ", input, "temp_R", R, "_", adapter, "_M", missM,".txt | agrep -", missM, " -b ", adapter, " | cut -f1 -d'='"))) - (length_adapter-1))
}
} else { # end lines_of_file > 0
agrep_position <- c()
}
poslist
### add vector to poslist
poslist <- append(poslist, agrep_position)
poslist
### change points to frequency over the readlength nt.
poscount <- table(poslist)
poscount
### correction loop due to first creation of poslist.
for (i in 0:readlength-1) {
poscount[i] <- poscount[i] -1
}
poscount
### change points to frequency over the readlength nt.
poscount <- table(poslist)
poscount
### correction loop due to first creation of poslist.
for (i in 0:readlength-1) {
poscount[i] <- poscount[i] -1
}
poscount
### change points to frequency over the readlength nt.
poscount <- table(poslist)
poscount[1]
poscount[1] - 1
### change points to frequency over the readlength nt.
poscount <- table(poslist)
poscount
### correction loop due to first creation of poslist.
for (i in 0:readlength-1) {
poscount[i] <- poscount[i] - 1
}
poscount
### change points to frequency over the readlength nt.
poscount <- table(poslist)
poscount[0]
poscount[0]
poscount[1]
poscount[150]
### change points to frequency over the readlength nt.
poscount <- table(poslist)
### correction loop due to first creation of poslist.
for (i in 1:readlength) {
poscount[i] <- poscount[i] - 1
}
poscount
save(poscount, file = paste0(input, paste0("Adapter_Positions_R", R, "_", adapter, "_M", missM, ".Rdata")))
devtools::document()
devtools::install()
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
adapter <- "AAA"
length_adapter <- nchar(adapter)
adapter <- as.character(adapter)
devtools::document()
devtools::install()
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
devtools::install()
library(paralle
library(paralle
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
grada_table_simple(input = "temp/example/")   # needs (kable, knitr)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 2, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 1, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 2, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 1, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 3, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 2, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
