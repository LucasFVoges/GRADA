# Old: pt_possibils <- lapply(length_adapter, function(i) choose(i, missM))[[1]]
pt_possibils <- choose(length_adapter, missM)
# the combinations are available via combn()
pt_combinations <- combn(1:length_adapter, missM, simplify = TRUE)    # error if missM higher than length of adapter!
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
## faster alternative?
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
# n <- 1  # num value for base
# for (base in strsplit(adapter, "")[[1]]) {
#   if (n %in% pt_combinations[,possibles]) {
#     if (n == length_adapter) {
#       regex_string <- paste0(regex_string, ".{0,1}")  # because insertion at the end is pointless.
#     } else {
#       regex_string <- paste0(regex_string, "(.{0,1}|", base, ".)") # This allown Indels as well. Without it would be just "."
#     }
#   } else {
#     regex_string <- paste0(regex_string, base)2
#   }
#   n <- n + 1
# }
# Warum lÃ¤uft das nicht????
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
#regex_string <- paste0(regex_string, "|")
}
# A little help for too time consuming approaches:
if (possibles %% 100 == 0 || possibles == pt_possibils) {
print(paste0("regex for ", missM, " mism.: ", possibles, " of ", pt_possibils, " combinations!"))
}
}
regex_string
adapter <- "AAAAAAAAAATTTTTTTTTTTCCCCCCCCCCTTTTTTTTTT"
missM <- 3
regex_string <- ""
length_adapter <- nchar(adapter)
char_adapter <- strsplit(adapter, "")[[1]]
# This will look in the pascal triangle for max number of possible combinations:
# Old: pt_possibils <- lapply(length_adapter, function(i) choose(i, missM))[[1]]
pt_possibils <- choose(length_adapter, missM)
# the combinations are available via combn()
pt_combinations <- combn(1:length_adapter, missM, simplify = TRUE)    # error if missM higher than length of adapter!
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
#regex_string <- paste0(regex_string, "|")
}
# A little help for too time consuming approaches:
if (possibles %% 100 == 0 || possibles == pt_possibils) {
print(paste0("regex for ", missM, " mism.: ", possibles, " of ", pt_possibils, " combinations!"))
}
}
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 2,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 2
)
grada_table_simple(input = "temp/example/")   # needs (kable, knitr)
```{r, eval=TRUE}3
library(GRADA)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar_full(PE = FALSE, skip = TRUE, input = "temp/example/", M_min = 3, M_max=0)
```
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar_full(PE = FALSE, skip = TRUE, input = "temp/example/", M_min = 3, M_max=0)
```
library(GRADA)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 2, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 3, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 3,M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 3, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 2, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 2, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 1, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
writeLines <- sessionInfo()
writeLines <- sessionInfo()
a <- writeLines(sessionInfo())
sink(file = "S1.txt")
sessionInfo()
sink()
"S
sink(file = "S1.txt")
func <- function(){
sink(file = "S1.txt")
sessionInfo()
sink()
}
func
func()
func()
func <- function(){
sink(file = "S1.txt", type = output)
sessionInfo()
sink()
}
func()
func <- function(){
sink(file = "S1.txt", type = "output")
sessionInfo()
sink()
}
func()
func <- function(){
sessionInfo() %>% capture.output("S1.txt")
}
func()
func <- function(){
sessionInfo() %>% capture.output("S1.txt")
}
func()
func <- function(){
sessionInfo() %>% capture.output(file = "S1.txt")
}
func()
library(dplyr)
func <- function(){
sessionInfo() %>% capture.output(file = "S1.txt")
}
func()
func <- function(){
capture.output(sessionInfo(), file = "S1.txt")
}
func()
func()
detach("package:dplyr", unload = TRUE)
func <- function(){
capture.output(sessionInfo(), file = "S1.txt")
}
func()
if(exists(data.dir)){print("yes")}
if(exists(data.dir)){print("yes")}
if(exists(data.dir)){print("yes")}
if(exists("data.dir")){print("yes")}
if(exists("data.dir")){print("yes")}
if(exists("data.dir")){print("yes")} else {print("No")}
if(exists("data.dir")){print("yes")} else {print("No")}
data.dir <- 2
if(exists("data.dir")){print("yes")} else {print("No")}
load("S1.txt")
read.table("S1.txt")
read.delim("S1.txt")
a <- read.delim("S1.txt")
View(a)
a
a[11]
a[[11]]
a(11)
a[,11]
a[11,]
a <- read.delim("S1.txt", sep = "$")
a
View(a)
a[11,]
a <- read.delim("S1.txt", sep = ":")
View(a)
a <- read.delim("S1.txt", sep = ":_")
a <- read.delim("S1.txt", sep = "_")
View(a)
a <- read.delim("S1.txt", sep = "_")
a <- read.delim("S1.txt", sep = "\n")
View(a)
a <- read.delim("S1.txt")
View(a)
a[11,]
readLines("S1.txt")
a <- readLines("S1.txt")
a[1]
a[12]
a[11]
load(*.txt)
choose(20,3)
choose(30,3)
regex_string <- ""
adapter <- "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
missM <- 3
length_adapter <- nchar(adapter)
char_adapter <- strsplit(adapter, "")[[1]]
# This will look in the pascal triangle for max number of possible combinations:
# Old: pt_possibils <- lapply(length_adapter, function(i) choose(i, missM))[[1]]
pt_possibils <- choose(length_adapter, missM)
# the combinations are available via combn()
pt_combinations <- combn(1:length_adapter, missM, simplify = TRUE)    # error if missM higher than length of adapter!
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (!simplify_regex){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
} else{
this_char_adapter[this_pos] <- "."
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
}
}
regex <- paste0("/",regex_string,"/")
regex_string
regex
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (!simplify_regex){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
} else{
this_char_adapter[this_pos] <- "."
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
}
}
simplyfy_regex <- FALSE
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (!simplify_regex){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
} else{
this_char_adapter[this_pos] <- "."
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
}
}
simplify_regex <- FALSE
for (this_pos in pt_combinations[,possibles]){
if (!simplify_regex){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
} else{
this_char_adapter[this_pos] <- "."
}
}
regex <- paste0("/",regex_string,"/")
regex
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (!simplify_regex){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
} else{
this_char_adapter[this_pos] <- "."
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
}
}
regex <- paste0("/",regex_string,"/")
regex
read.table("Dokumente/Temp/csv.ods)
table <- read.table("Dokumente/Temp/csv.ods)
table <- read.table("Dokumente/Temp/csv.ods)
table <- read.table("Dokumente/Temp/csv.ods")
table <- read.table("Dokumente/Temp/csv.ods")
table <- read.table("Dokumente/Temp/csv.csv")
table
table <- read.table("Dokumente/Temp/csv.csv", sep = ",")
table
table <- read.table("Dokumente/Temp/csv.csv", sep = ",", header = TRUE)
table
table1 <- table[1,2]
table1 <- table[1:2]
table1
table2 <- table[3:4]
table2
table1[2]
table1[2][1]
table1[2,1]
table1[2]
table1[1,2]
table1[2,2]
table1[3,2]
table1[4,2]
for (i in table1[2]){print(i)}
for (i in table1){print(i)}
for (i in table1[1]){print(i)}
tatable1[9955,2]
table1[9955,2]
table1
table1[90342,2]
table1[90342]
table1[90342,2]
table1
length(table1)
table1[1]
table1[,1]
table1[,2]
table1[,1]
for (row in table1[,1]) {print(row) }
}
for (row in table1[,1]) {print(row) }
table1$Start
setwd("~/Dokumente/GITHUB/GRADA")
load("/home/voges/Dokumente/GITHUB/GRADA/example/temp/example/Adapter_Positions_M3.Rdata")
#### Load Data ####
plotlist <- list()
plotlist[[MMs+1]] <- adapter_positions
MMs <- 3
plotlist[[MMs+1]] <- adapter_positions
plotlist
MMs <- 2
plotlist[[MMs+1]] <- adapter_positions
plotlist
row.names(plotlist[[4]])
row.names(plotlist[[4]]["test R_1"])
plotlist[[4]]["test R_1"]
setwd("~/Dokumente/GITHUB/GRADA/example")
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 2, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
library(GRADA)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 2, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 2, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
write("TEST", file = "search.awk")
write()
adapter <- "AAA"
missM <- 2
R <- 1
input <- "temp/example/"
### AWK search for positions:
awk_string <- paste0(input, "temp_search_R", R, "_", adapter, "_M", missM, ".awk")
awk_string
regex_string <- adapter
regex_string <- "AAA|AAA|TTT"
write(x = paste0("match($0, /", regex_string, "/) {s=$0; m=0; while((n=match(s, /", regex_string, "/))>0){m+=n; printf \"%s,\", m; m+=", nchar(adapter)-1, "; s=substr(s, n+", nchar(adapter),")}}"), file = awk_string)
file("test.txt", "r")
a <- file("test.txt", "r")
a
content <- readLines(a)
content
close(a)
aregexec("aaa", content, fixed = TRUE, max.distance = 2)
a <- aregexec("aaa", content, fixed = TRUE, max.distance = 2)
a
devtools::document()
devtools::install()
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
devtools::install()
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
grada_table_simple(input = "temp/example/")   # needs (kable, knitr)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 2, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 2, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 2, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8,
method = "awk"
)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 2, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
devtools::document()
devtools::install()
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
