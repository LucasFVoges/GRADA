print(paste0("regex for ", missM, " mism.: ", possibles, " of ", pt_possibils, " combinations!"))
}
}
regex_string
regex_string <- ""
length_adapter <- nchar(adapter)
char_adapter <- strsplit(adapter, "")[[1]]
# This will look in the pascal triangle for max number of possible combinations:
# Old: pt_possibils <- lapply(length_adapter, function(i) choose(i, missM))[[1]]
pt_possibils <- choose(length_adapter, missM)
# the combinations are available via combn()
pt_combinations <- combn(1:length_adapter, missM, simplify = TRUE)    # error if missM higher than length of adapter!
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
## faster alternative?
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
# n <- 1  # num value for base
# for (base in strsplit(adapter, "")[[1]]) {
#   if (n %in% pt_combinations[,possibles]) {
#     if (n == length_adapter) {
#       regex_string <- paste0(regex_string, ".{0,1}")  # because insertion at the end is pointless.
#     } else {
#       regex_string <- paste0(regex_string, "(.{0,1}|", base, ".)") # This allown Indels as well. Without it would be just "."
#     }
#   } else {
#     regex_string <- paste0(regex_string, base)2
#   }
#   n <- n + 1
# }
# Warum läuft das nicht????
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
#regex_string <- paste0(regex_string, "|")
}
# A little help for too time consuming approaches:
if (possibles %% 100 == 0 || possibles == pt_possibils) {
print(paste0("regex for ", missM, " mism.: ", possibles, " of ", pt_possibils, " combinations!"))
}
}
regex_string
adapter <- "AAAAAAAAAAATTTTTTTTT"
missM <- 3
regex_string <- ""
length_adapter <- nchar(adapter)
char_adapter <- strsplit(adapter, "")[[1]]
# This will look in the pascal triangle for max number of possible combinations:
# Old: pt_possibils <- lapply(length_adapter, function(i) choose(i, missM))[[1]]
pt_possibils <- choose(length_adapter, missM)
# the combinations are available via combn()
pt_combinations <- combn(1:length_adapter, missM, simplify = TRUE)    # error if missM higher than length of adapter!
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
## faster alternative?
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
# n <- 1  # num value for base
# for (base in strsplit(adapter, "")[[1]]) {
#   if (n %in% pt_combinations[,possibles]) {
#     if (n == length_adapter) {
#       regex_string <- paste0(regex_string, ".{0,1}")  # because insertion at the end is pointless.
#     } else {
#       regex_string <- paste0(regex_string, "(.{0,1}|", base, ".)") # This allown Indels as well. Without it would be just "."
#     }
#   } else {
#     regex_string <- paste0(regex_string, base)2
#   }
#   n <- n + 1
# }
# Warum läuft das nicht????
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
#regex_string <- paste0(regex_string, "|")
}
# A little help for too time consuming approaches:
if (possibles %% 100 == 0 || possibles == pt_possibils) {
print(paste0("regex for ", missM, " mism.: ", possibles, " of ", pt_possibils, " combinations!"))
}
}
regex_string
adapter <- "AAAAAAAAAATTTTTTTTTTTCCCCCCCCCCTTTTTTTTTT"
missM <- 3
regex_string <- ""
length_adapter <- nchar(adapter)
char_adapter <- strsplit(adapter, "")[[1]]
# This will look in the pascal triangle for max number of possible combinations:
# Old: pt_possibils <- lapply(length_adapter, function(i) choose(i, missM))[[1]]
pt_possibils <- choose(length_adapter, missM)
# the combinations are available via combn()
pt_combinations <- combn(1:length_adapter, missM, simplify = TRUE)    # error if missM higher than length of adapter!
# generate the adapter regex:
for (possibles in 1:pt_possibils) {
this_char_adapter <- char_adapter
for (this_pos in pt_combinations[,possibles]){
if (this_pos == length_adapter) {
# because insertion at the end is pointless.
this_char_adapter[this_pos] <- ".{0,1}"
} else {
# This allown Indels as well. Without it would be just "."
this_char_adapter[this_pos] <- paste0("(.{0,1}|", char_adapter[this_pos], ".)")
}
}
regex_string <- paste0(regex_string, paste0(this_char_adapter, collapse = ""), "|")
if (possibles == pt_possibils) {          # so in the end is no "|"
regex_string <- substr(regex_string, 1, nchar(regex_string)-1)
#regex_string <- paste0(regex_string, "|")
}
# A little help for too time consuming approaches:
if (possibles %% 100 == 0 || possibles == pt_possibils) {
print(paste0("regex for ", missM, " mism.: ", possibles, " of ", pt_possibils, " combinations!"))
}
}
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 2,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 2
)
grada_table_simple(input = "temp/example/")   # needs (kable, knitr)
```{r, eval=TRUE}3
library(GRADA)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar_full(PE = FALSE, skip = TRUE, input = "temp/example/", M_min = 3, M_max=0)
```
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar_full(PE = FALSE, skip = TRUE, input = "temp/example/", M_min = 3, M_max=0)
```
library(GRADA)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 2, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 3, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 3,M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 3, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 2, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 2, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
grada_plot_bar(PE = FALSE, skip = FALSE, full_length = TRUE, input = "temp/example/", colour = 1, M_min = 0, M_max=2, plot_row = 1, plot_col = 1)
adapter <- "AAAAAAAAAAAAAAAAAAAA"
missM <- 4
missM <- 3
setwd("~/Dokumente/GITHUB/GRADA/example")
library(GRADA)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 2, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
library(GRADA)
library(parallel)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
devtools::document()
devtools::install()
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
devtools::install()
library(GRADA)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
devtools::document()
devtools::install()
library(GRADA)
library(parallel)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
grada_plot_bar(PE = FALSE, skip = FALSE, input = "temp/example/", colour = 2, M_min = 0, M_max=8, plot_row = 1, plot_col = 1)
awk_positions <- ""
### build vector
positions <- as.vector(as.numeric(unlist(strsplit(awk_positions, ","))))
poslist <- c(1:10)
poslist <- append(poslist, positions)
poslist
poslist <- c(1:10)
poslist
### change points to frequency over the readlength nt.
poscount <- table(poslist)
### correction loop due to first creation of poslist.
for (i in 1:10) {
poscount[i] <- poscount[i] -1
}
poscount
### build vector
positions <- as.vector(as.numeric(unlist(strsplit(awk_positions, ","))))
awk_positions <- ""
### build vector
positions <- as.vector(as.numeric(unlist(strsplit(awk_positions, ","))))
positions
poslist <- append(poslist, positions)
poslist <- append(poslist, positions)
poslist <- append(poslist, positions)
poslist
devtools::document()
devtools::install()
library(GRADA)
library(parallel)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
devtools::install()
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
devtools::install()
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8,
indels = FALSE
)
devtools::document()
devtools::install()
library(GRADA)
library(parallel)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8,
indels = FALSE
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8,
indels = TRUE
)
grada_analyze(
PE = FALSE,                 # analyze paired data (or 2 read files)
read1 = "example.fastq.gz",    # read file (fastq, txt ... anything agrep works with.)
read2 = NULL,               # read2 file if PE
seq = "seq_adapter_2.txt",    # adapter files
M_min = 0,                  # minimal mismatches (0 is required for plotting.)
M_max = 8,                  # maximal mismatches
output = "temp/example/",   # the folder for the created data (will be large)
keepfiles = TRUE,           # keep them for analyze_positions! (can be deleted on the fly for very big data...)
numCores = detectCores()/2  # parallel computing (will be slow at "1")
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8,
indels = TRUE
)
grada_analyze_positions(
PE = FALSE,
readlength = 150,           # this option is needed, it is the maximal read length.
input = "temp/example/",    # grada_table.txt should be here!
numCores = detectCores()/2,
keepfiles = TRUE,           # the temporary files (from before) will be kept!
M_min = 0,
M_max = 8,
indels = FALSE
)
